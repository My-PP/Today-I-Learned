
# Система контроля версий Git

<a id="git"></a>

[Оглавление TIL](/README.md#start)

- [Что такое Git](#1)
- [Версионирование](#2)
- [Установка в Windows](#3)
- [Установка в Linux](#4)
- [Установка на macOS](#5)
- [Первоначальная настройка Git](#6)

Репозиторий - часть системы Git, которая позволяет совместно работать над проектами, хранилище всех версий кода. Для работы с репозиториями нужен удобный сервис. Самые популярные: GitHub, GitLab и Bitbucket.

- [Что такое GitHub и чем он отличается от Git?](/Git/GitHub/README.md)
- [GitLab – набирающая популярность альтернатива GitHub](/Git/GitLab/README.md)
- [Bitbucket – еще один популярный инструмент](/Git/Bitbucket/README.md)

Команды, которые следует знать, чтобы освоить управление репозиториями на высоком уровне. Ознакомиться с ними будет полезно как новичкам, так и опытным разработчикам.

- [Основная шпаргалка по командам Git](#8)
  - [по основным командам](#8-1)
  - [по ветвлению и слиянию](#8-2)
  - [по совместной работе и обновлению проектов](#8-3)
  - [по осмотру и сравнению](#8-4)
  - [по отладке](#8-5)
- [Расширенная шпаргалка](#7)
  - [восстановление накопленных изменений](#7-1)
  - [восстановление удалённого тега](#7-2)
  - [восстановление удалённого файла](#7-3)
  - [восстановление удалённой ветки](#7-4)
  - [изменение сообщения коммита перед его отправкой](#7-5)
  - [изменение сообщения коммита после его отправки](#7-6)
  - [коммит в неправильную ветку](#7-7)
  - [откат к конкретному коммиту в истории](#7-8)
  - [отмена коммита до публикации изменений](#7-9)
  - [отмена коммита после отправки его в master-репозиторий](#7-10)
  - [отмена локальных изменений файлов](#7-11)
  - [отображение всех коммитов одного файла](#7-12)
  - [переименование локальной и удалённой ветки](#7-13)
  - [переименование тега](#7-14)
  - [перестать отслеживать существующие файлы](#7-15)
  - [подготовка удалённых файлов](#7-16)
  - [просмотр всех неотправленных коммитов](#7-17)
  - [просмотр старой ревизии файла](#7-18)
  - [публикация локальной ветки для удалённого редактирования](#7-19)
  - [сброс локальной ветки до состояния удалённой](#7-20)
  - [синхронизировать ветку с master-репозиторием](#7-21)
  - [слияние локальных изменений с другой веткой](#7-22)
  - [создание новой ветки с изменениями текущей](#7-23)
  - [убрать файл из буфера](#7-24)
  - [удаление внешней ветки](#7-25)
  - [удаление неотслеживаемых файлов и папок](#7-26)
  - [удаление старых веток, стёртых из внешнего репозитория](#7-27)

**Полезный совет - полюбите командную строку, используйте её вместо IDE**

Используйте командную строку — на то есть столько же причин, сколько команд в Git. Командная строка — очень мощный инструмент, как и IDE, но они хороши каждый по-своему. Когда нужно использовать Git на полную катушку, командная строка вне конкуренции.

Помните об автодополнении, такая функция есть и в Bash, и в Zsh, и в Powershell. Автодополнение избавляет вас от необходимости запоминать полные команды.
  
## Что такое Git

<a id="1"></a>

Git — самая популярная распределённая система контроля версий, которая позволяет хранить разные версии одного и того же документа, переключаться
между ранними и поздними вариантами, вносить и отслеживать изменения. Поэтому в любой момент можно отменить правки или исключить ненужные части кода.

Git-сервисы позволяют переключаться между ветками кода и просматривать коммиты.

Работа с Git ведётся через командную строку. В разных операционных системах свои программы для взаимодействия с Git. В Windows их две: PowerShell и cmd.exe.
В Ubuntu это Terminal. Самая популярная программа на macOS тоже называется Terminal.
Подобные программы еще называют «терминал» или «консоль». Мы вводим команду и получаем реакцию машины: сообщение об ошибке, запрос на подтверждение
информации, результат выполненных действий.

Распределенная система контроля версий означает, что локальный клон проекта является полным репозиторием управления версиями. Полнофункциональные локальные репозитории упрощают работу в автономном режиме или в удаленном расположении.

Основное предназначение Git – это сохранение снимков последовательно улучшающихся состояний вашего проекта. С помощью Git можно отслеживать и контролировать все изменения, вносимые в базу кода проекта. Основной структурный элемент в системе Git называется репозиторий. Он представляет собой отдельный каталог на удаленном сервере, в котором хранятся все файлы для конкретного проекта: программный код, изображения, аудио, видео, документация и т.д.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Версионирование

<a id="2"></a>

Чтобы лучше понять проблему версионирования, рассмотрим пример дизайнера, который закончил работать над проектом и отправил финальную версию заказчику. У дизайнера есть папка, в которой хранится финальная версия проекта:

```text
source/
barbershop_index_final.psd
```

Всё хорошо, дизайнер закончил работу, но заказчик прислал в ответ правки. Чтобы была возможность вернуться к старой версии проекта, дизайнер создал новый файл `barbershop_index_final_2.psd`, внёс изменения и отправил заказчику:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
```

Этим всё не ограничилось, в итоге структура проекта разрослась и стала выглядеть так:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
…
barbershop_index_final_19.psd
…
barbershop_index_latest_final.psd
barbershop_index_latest_final_Final.psd
```

Вероятно, многие уже сталкивались с подобным, например, при написании курсовых работ во время учёбы. В разработке создавать новые файлы для версионирования — плохая практика. Обычно у разработчиков в папке проекта хранится множество файлов. Также над одним проектом может работать несколько человек. Если каждый разработчик для версионирования будет создавать новый файл, немного изменяя название предыдущей версии, то в скором времени в проекте начнётся хаос и никто не будет понимать, какие файлы нужно открывать.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Windows

<a id="3"></a>

Скачайте exe-файл с [cайта Git](https://git-scm.com/downloads) и запустите его. Это Git для Windows, он называется msysGit. Установщик спросит добавлять ли в меню проводника возможность запуска файлов с помощью Git Bash (консольная версия) и GUI (графическая версия). Подтвердите действие, чтобы далее вести работу через консоль в Git Bash. Остальные пункты можно оставить по умолчанию.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Linux

<a id="4"></a>

Используйте обычный менеджер пакетов вашего дистрибутива. Откройте терминал и введите подходящие команды.

- Если у вас 21 или более ранняя версия Fedora, используйте `yum install git`.
- Для 22 и последующих версий Fedora вводите `dnf install git`.
- Для дистрибутивов, основанных на Debian, например, Ubuntu, используйте `apt-get: sudo apt-get install git`.

Полный список команд для различных дистрибутивов можно посмотреть [здесь](https://git-scm.com/download/linux).

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка на macOS

<a id="5"></a>

- Скачиваем Git со страницы [проекта](https://git-scm.com/download/mac).
- Запускаем загруженный файл.
- Система может показать окно с ошибкой, где будет написано, что файл скачан с неавторизованного сайта и инсталлятор не может быть запущен. В таком случае нужно зайти в «Системные настройки» — «Безопасность» (Security and Privacy), в появившемся окне будет сообщение об ошибке и кнопка Open anyway (Всё равно открыть). Нажимаем.
- Система покажет окно, уточняющее хотите ли вы запустить установку. Подтверждаем действие.
- Установщик проведёт через все необходимые шаги.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Первоначальная настройка Git

<a id="6"></a>

Работа с любой программой всегда начинается с её настройки. Git можно настроить один раз и менять что-то только по мере необходимости.

Установка имени пользователя, от которого будут идти коммиты.

`git config --global user.name "User Name"`

![Git](/img/Git/Git-setup-1.png)

Установка адреса электронной почты. Обратите внимание, что адрес должен совпадать с тем, на который зарегистрирован аккаунт в Гитхабе.

`git config --global user.email mail@gmail.com`

![Git](/img/Git/Git-setup-2.png)

С помощью команды git config --list можно посмотреть список всех установленных настроек.

![Git](/img/Git/Git-setup-3.png)

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Расширенная шпаргалка

<a id="7"></a>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление накопленных изменений

<a id="7-1"></a>

В том случае, если изменения, внесённые пользователем, находятся в режиме накопления, применить их к ветке можно с помощью команды git stash apply. Также можно запустить git diff — эта команда поможет выявить различия. Для того, чтобы затем избавиться от накопленных данных, нужно запустить команду:

```bash
git stash drop
```

Если существует более одного накопления, найти нужное можно с помощью команды:

`git stash list` затем можно применить его, воспользовавшись его индексом:

```bash
git stash@{1}
```

Необходимо учитывать, что отсчёт индексов ведётся от нуля.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённого тега

<a id="7-2"></a>

В том случае, если необходимо восстановить случайно удалённый тег, начать можно с его поиска:

```bash
git fsck --unreachable | grep ta
```

После того, как нужный тег найден, его следует восстановить:

```bash
git update-ref refs/tags/название-тега
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённого файла

<a id="7-3"></a>

Если вы случайно удалили файл, его можно быстро восстановить:

```bash
git checkout myfile.txt
```

Если требуется восстановить файл из конкретной временной точки истории коммитов, следует узнать хеш нужного коммита и запустить команду:

```bash
git checkout $commit~1 myfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённой ветки

<a id="7-4"></a>

С помощью комманды git reflog можно узнать хеш (SHA1) последнего коммита в удалённой ветке. Скопируйте этот хеш и используйте в команде:

```bash
git checkout <sha>
```

После этого восстановить удалённую ветку можно будет вот такой командой:

```bash
git checkout -b <название-ветки>
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Изменение сообщения коммита перед его отправкой

<a id="7-5"></a>

Изменить сообщение коммита можно с помощью команды `git commit --amend`, она откроет редактор, в котором можно будет внести необходимые поправки в последнее сообщение.

Сообщение можно изменить и напрямую с помощью команды

```bash
git commit --amend -m "Новое прекрасное сообщение"
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Изменение сообщения коммита после его отправки

<a id="7-6"></a>

В данном случае процесс занимает два шага. Сначала нужно изменить сообщение с помощью комманды `git commit --amend`, а затем перезаписать историю коммитов локальной ветки: `git push <remote> <branch> --force`

**Предупреждение:** подобная насильная перезапись может привести к потери коммитов из внешней ветки, если с ней давно не было синхронизации, соблюдайте осторожность.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Коммит в неправильную ветку

<a id="7-7"></a>

Нужно переключиться на новую ветку, которую вы забыли предварительно создать:

```bash
git checkout -b название-новой-ветки.
```

А затем переключиться к оригинальной ветке:

```bash
git checkout название-оригинальной-ветки
```

...и «откатиться» до последнего коммита, который нужно сохранить.

Чтобы это сделать, можно воспользоваться командой git log и сохранить хеш (SHA1) последнего коммита, который нужно оставить.. Например, это a31a45c.

Теперь его нужно сбросить: `git reset --hard a31a45c` и отправить получившийся результат.

**Предупреждение:** Убедитесь в том, что никто не отправлял коммиты в оригинальную ветку во время выполнения вышеописанных процедур, в противном случае эти изменения будут потеряны!

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Откат к конкретному коммиту в истории

<a id="7-8"></a>

Если вас не очень беспокоят изменения в локальном репозитории, то можно «откатиться» к конкретному коммиту в истории с помощью команды:

```bash
git reset --hard HEAD~1
```

Эта команда установит HEAD на конкретный коммит. Также можно воспользоваться хешем коммита.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена коммита до публикации изменений

<a id="7-9"></a>

Если вы сделали коммит, который впоследствии понадобилось отредактировать или полностью стереть, поможет команда git reset.

```bash
git reset HEAD~1 # отменить последний коммит, сохранить изменения
git reset --hard HEAD~1 # отменить последний коммит, стереть изменения
```

Будьте осторожны используя второй вариант, поскольку изменения ваших локальных файлов будут потеряны.

Чтобы сохранить сообщение коммита, наберите: :

```bash
git commit -i ORIG_HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена коммита после отправки его в master-репозиторий

<a id="7-10"></a>

Рассмотрим процедуру возврата одного или нескольких коммитов, которые нужно стереть из удалённой ветки. Обозначить конкретный коммит можно с помощью его хеша:

```bash
git revert b712c3c
```

Отмена только коммита, который является вторым после последнего:

```bash
git revert HEAD^
```

Простая отмена последнего коммита:

```bash
git revert -n HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена локальных изменений файлов

<a id="7-11"></a>

Простейшим способом избавиться от нежелательных изменений для файлов и папок является восстановление состояния последнего коммита. Сделать это можно с помощью специальной команды:

```bash
git checkout myfile.txt
```

Кроме того, можно восстановить конкретный путь к файлу:

```bash
git checkout -- путь-до-файла
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отображение всех коммитов одного файла

<a id="7-12"></a>

Если вы хотите просмотреть все коммиты с изменениями конкретного файла, воспользуйтесь командой `git log --follow -p -- myfile`

Аргумент —follow позволяет вывести все изменения над файлом, даже если в процессе работы он был переименован.

Если опустить опцию -p, то система выведет только сообщения коммитов, но не их содержимое.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Переименование локальной и удалённой ветки

<a id="7-13"></a>

Предложим, у вас есть ветка *«fix-bug25»*, которую вы захотели переименовать в *«hotfix-users»*. Прежде всего, нужно будет изменить локальную ветку:

```bash
git branch -m fix-bug25 hotfix-users
```

А затем — удалённую ветку: переименовать её напрямую нельзя, поэтому нужно будет её удалить, и затем опубликовать заново уже с новым именем. Прежде чем приступать к этим процедурам, следует убедиться, что никто из членов команды не работает с этой веткой! Удаляем ветку: `git push origin :fix-bug25`

А теперь заново публикуем её с новым именем: `git push origin hotfix-users`

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Переименование тега

<a id="7-14"></a>

Чтобы переименовать существующий тег:

```bash
git tag новое-название-тега старое-название-тега
git tag -d старое-название-тега
git push origin :refs/tags/старое-название-тега
git push --tags
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Перестать отслеживать существующие файлы

<a id="7-15"></a>

Если вы хотите перестать отслеживать файлы, которые уже есть в репозитории, но при этом желаете сохранить его локально, осуществите коммит изменений и запустите команду:

```bash
git rm -r --cached
```

Она удалит изменённые файлы из зоны подготовленных файлов (staging area). Затем нужно запустить команду:

```bash
git add .
```

и отправить изменения.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Подготовка удалённых файлов

<a id="7-16"></a>

Чтобы подготовить к коммиту файлы и папки, которые были удалены локально, можно использовать специальную команду:

```bash
git add -u
```

Если требуется подготовить только используемый в данный момент путь, воспользуйтесь командой

```bash
git add -u .
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Просмотр всех неотправленных коммитов

<a id="7-17"></a>

Чтобы просмотреть все коммиты, которые ещё не были отправлены в соответствующие ветки, воспользуйтесь следующей командой:

```bash
git log --branches --not --remotes
```

Кроме того, можно использовать:

```bash
git log origin/master..HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Просмотр старой ревизии файла

<a id="7-18"></a>

Существует возможность просмотреть содержимое файла в конкретный момент времени в прошлом. Для этого нужно использовать команду:

```bash
git show commitHash:myfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Публикация локальной ветки для удалённого редактирования

<a id="7-19"></a>

Если вы создали локальную ветку, и хотите, чтобы другие пользователи могли с ней работать, воспользуйтесь командой:

```bash
git push -u origin название-моей-новой-ветки
```

Теперь они тоже смогут вносить изменения в эту ветку.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Сброс локальной ветки до состояния удалённой

<a id="7-20"></a>

В том случае, если отсутствуют изменения, которые необходимо сохранить, сбросить локальную ветку до состояния удалённой можно с помощью двух простых команд.

Прежде всего нужно получить свежие обновления из удалённой ветки:

```bash
git fetch название-удалённой-ветки.
```

А затем нужно сообщить git, что локальную ветку следует «откатить» до состояния удалённой:

```bash
git reset --hard origin/название-локальной-ветки.
```

При наличии коммита, который нужно сохранить, перед сбросом нужно создать новую ветку и произвести коммит: git commit -m «Обновление»

```bash
git branch название-новой-ветки
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Синхронизировать ветку с master-репозиторием

<a id="7-21"></a>

Чтобы синхронизировать последние изменения в репозитории master (или с любой другой веткой, с которой вы работали) необходимо «перебазировать» локальную ветку. Предположим, вы работаете над веткой foobar:

```bash
git checkout foobar
```

А затем осуществляете «перебазирование»:

```bash
git rebase master
```

После этого будут применены коммиты origin из master. После разрешения конфликтов процесс можно продолжить с помощью команды git rebase —continue. Теперь можно продолжать работу над своей веткой или осуществить её слияние (merge) с главным репозиторием.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Слияние локальных изменений с другой веткой

<a id="7-22"></a>

Это можно сделать прямо в процессе стандартного слияния (merge). Вам стоит *сохранить историю слияний* используя флаг —no-ff, что означает *no fast forward*.

Перейдите в ветку, в которую будут вливаться изменения, убедитесь в её актуальности и запустите процесс:

```bash
git merge <другая-ветка> --no-ff
```

Затем появится сообщение о коммите merge X into Y branch, после чего вы можете смело запушить ваше слияние.>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Создание новой ветки с изменениями текущей

<a id="7-23"></a>

Часто возникает ситуация, при которой пользователи начинают изменять файлы в ветке, чтобы что-то исправить, и лишь позднее вспоминают, что предварительно не создали новую ветку. К счастью, есть способ сделать это уже в процессе:

```bash
git checkout -b название-моей-новой-ветки
```

Эта команда перенесёт файлы из текущей ветки в новую, которую потом уже можно «закоммитить».

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Убрать файл из буфера

<a id="7-24"></a>

Чтобы убрать добавленный по ошибке файл из буфера, нужно воспользоваться простой командой:

```bash
git reset HEAD unlovedfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление внешней ветки

<a id="7-25"></a>

Если вы хотите удалить ветку, введите команду:

```bash
git push origin --delete название-ветки
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление неотслеживаемых файлов и папок

<a id="7-26"></a>

Чтобы удалить неотслеживаемые файлы и папки из рабочей копии наберите следующую команду:

```bash
git clean -f
```

Чтобы в принципе удалить их:

```bash
git clean -fd
```

Подсказка: чтобы увидеть, какие файлы являются лишними, перед их непосредственным удалением, наберите:

```bash
git clean -n
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление старых веток, стёртых из внешнего репозитория

<a id="7-27"></a>

Если ветка удалена из внешнего репозитория, её также можно стереть из локального репозитория с помощью команды

```bash
git-remote prune название-удалённой-ветки
```

Она удалит старую ветку под названием *название-удалённой-ветки*, которая уже была стёрта из внешнего репозитория, но всё ещё доступна локально в remotes/название-удалённой-ветки.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Основная шпаргалка по командам Git

<a id="8"></a>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По основным командам

<a id="8-1"></a>

```bash
git add
```

команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

```bash
git status
```

команда git status показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

```bash
git diff
```

команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

```bash
git difftool
```

команда git difftool просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

```bash
git commit
```

команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

```bash
git reset
```

команда git reset, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра --hard, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

```bash
git rm
```

команда git rm используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

```bash
git mv
```

команда git mv — это всего лишь удобный способ переместить файл, а затем выполнить git addдля нового файла и git rm для старого.

```bash
git clean
```

команда git clean используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По ветвлению и слиянию

<a id="8-2"></a>

```bash
git branch
```

Команда git branch — это своего рода “менеджер веток”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

```bash
git checkout
```

Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочую директорию.

```bash
git merge
```

Команда git merge используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

```bash
git mergetool
```

Команда git mergetool просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

```bash
git log
```

Команда git log используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

```bash
git stash
```

Команда git stash используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

```bash
git tag
```

Команда git tag используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По совместной работе и обновлению проектов

<a id="8-3"></a>

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

```bash
git fetch
```

Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

```bash
git pull
```

Команда git pull работает как комбинация команд git fetch и git merge, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

```bash
git push
```

Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

```bash
git remote
```

Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

```bash
git archive
```

Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

```bash
git submodule
```

Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По осмотру и сравнению

<a id="8-4"></a>

```bash
git show
```

Команда git show отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

```bash
git shortlog
```

Команда git shortlog служит для подведения итогов команды git log. Она принимает практически те же параметры, что и git log, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

```bash
git describe
```

Команда git describe принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По отладке

<a id="8-5"></a>

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

```bash
git bisect
```

Команда git bisect — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

```bash
git blame
```

Команда git blame выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

```bash
git grep
```

Команда git grep используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)