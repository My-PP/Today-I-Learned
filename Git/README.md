
# Система контроля версий Git

<a id="git"></a>

[Оглавление TIL](/README.md#start)

- [Что такое Git](#1)
- [Версионирование](#2)
- [Установка в Windows](#3)
- [Установка в Linux](#4)
- [Установка на macOS](#5)
- [Первоначальная настройка Git](#6)

Репозиторий - часть системы Git, которая позволяет совместно работать над проектами, хранилище всех версий кода. Для работы с репозиториями нужен удобный сервис. Самые популярные: GitHub, GitLab и Bitbucket.

- [Что такое GitHub и чем он отличается от Git?](/Git/GitHub/README.md)
- [GitLab – набирающая популярность альтернатива GitHub](/Git/GitLab/README.md)
- [Bitbucket – еще один популярный инструмент](/Git/Bitbucket/README.md)

Cамые основные команды, которые следует знать, чтобы освоить управление репозиториями на высоком уровне. Ознакомиться с ними будет полезно как новичкам, так и опытным разработчикам.

- [Шпаргалка по Git](#7)
  - [Восстановление накопленных изменений](#7-1)
  - [Восстановление удалённого тега](#7-2)
  - [Восстановление удалённого файла](#7-3)
  - [Восстановление удалённой ветки](#7-4)
  - [Изменение сообщения коммита перед его отправкой](#7-5)
  - [Изменение сообщения коммита после его отправки](#7-6)
  - [Коммит в неправильную ветку](#7-7)
  - [Откат к конкретному коммиту в истории](#7-8)
  - [Отмена коммита до публикации изменений](#7-9)
  - [Отмена коммита после отправки его в master-репозиторий](#7-10)
  - [Отмена локальных изменений файлов](#7-11)
  - [Отображение всех коммитов одного файла](#7-12)
  - [Переименование локальной и удалённой ветки](#7-13)
  - [Переименование тега](#7-14)
  - [Перестать отслеживать существующие файлы](#7-15)
  - [Подготовка удалённых файлов](#7-16)
  - [Просмотр всех неотправленных коммитов](#7-17)
  - [Просмотр старой ревизии файла](#7-18)
  - [Публикация локальной ветки для удалённого редактирования](#7-19)
  - [Сброс локальной ветки до состояния удалённой](#7-20)
  - [Синхронизировать ветку с master-репозиторием](#7-21)
  - [Слияние локальных изменений с другой веткой](#7-22)
  - [Создание новой ветки с изменениями текущей](#7-23)
  - [Убрать файл из буфера](#7-24)
  - [Удаление внешней ветки](#7-25)
  - [Удаление неотслеживаемых файлов и папок](#7-26)
  - [Удаление старых веток, стёртых из внешнего репозитория](#7-27)
  
## Что такое Git

<a id="1"></a>

Git — самая популярная распределённая система контроля версий, которая позволяет хранить разные версии одного и того же документа, переключаться
между ранними и поздними вариантами, вносить и отслеживать изменения. Поэтому в любой момент можно отменить правки или исключить ненужные части кода.

Git-сервисы позволяют переключаться между ветками кода и просматривать коммиты.

Работа с Git ведётся через командную строку. В разных операционных системах свои программы для взаимодействия с Git. В Windows их две: PowerShell и cmd.exe.
В Ubuntu это Terminal. Самая популярная программа на macOS тоже называется Terminal.
Подобные программы еще называют «терминал» или «консоль». Мы вводим команду и получаем реакцию машины: сообщение об ошибке, запрос на подтверждение
информации, результат выполненных действий.

Распределенная система контроля версий означает, что локальный клон проекта является полным репозиторием управления версиями. Полнофункциональные локальные репозитории упрощают работу в автономном режиме или в удаленном расположении.

Основное предназначение Git – это сохранение снимков последовательно улучшающихся состояний вашего проекта. С помощью Git можно отслеживать и контролировать все изменения, вносимые в базу кода проекта. Основной структурный элемент в системе Git называется репозиторий. Он представляет собой отдельный каталог на удаленном сервере, в котором хранятся все файлы для конкретного проекта: программный код, изображения, аудио, видео, документация и т.д.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Версионирование

<a id="2"></a>

Чтобы лучше понять проблему версионирования, рассмотрим пример дизайнера, который закончил работать над проектом и отправил финальную версию заказчику. У дизайнера есть папка, в которой хранится финальная версия проекта:

```text
source/
barbershop_index_final.psd
```

Всё хорошо, дизайнер закончил работу, но заказчик прислал в ответ правки. Чтобы была возможность вернуться к старой версии проекта, дизайнер создал новый файл `barbershop_index_final_2.psd`, внёс изменения и отправил заказчику:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
```

Этим всё не ограничилось, в итоге структура проекта разрослась и стала выглядеть так:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
…
barbershop_index_final_19.psd
…
barbershop_index_latest_final.psd
barbershop_index_latest_final_Final.psd
```

Вероятно, многие уже сталкивались с подобным, например, при написании курсовых работ во время учёбы. В разработке создавать новые файлы для версионирования — плохая практика. Обычно у разработчиков в папке проекта хранится множество файлов. Также над одним проектом может работать несколько человек. Если каждый разработчик для версионирования будет создавать новый файл, немного изменяя название предыдущей версии, то в скором времени в проекте начнётся хаос и никто не будет понимать, какие файлы нужно открывать.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Windows

<a id="3"></a>

Скачайте exe-файл с [cайта Git](https://git-scm.com/downloads) и запустите его. Это Git для Windows, он называется msysGit. Установщик спросит добавлять ли в меню проводника возможность запуска файлов с помощью Git Bash (консольная версия) и GUI (графическая версия). Подтвердите действие, чтобы далее вести работу через консоль в Git Bash. Остальные пункты можно оставить по умолчанию.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Linux

<a id="4"></a>

Используйте обычный менеджер пакетов вашего дистрибутива. Откройте терминал и введите подходящие команды.

- Если у вас 21 или более ранняя версия Fedora, используйте `yum install git`.
- Для 22 и последующих версий Fedora вводите `dnf install git`.
- Для дистрибутивов, основанных на Debian, например, Ubuntu, используйте `apt-get: sudo apt-get install git`.

Полный список команд для различных дистрибутивов можно посмотреть [здесь](https://git-scm.com/download/linux).

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка на macOS

<a id="5"></a>

- Скачиваем Git со страницы [проекта](https://git-scm.com/download/mac).
- Запускаем загруженный файл.
- Система может показать окно с ошибкой, где будет написано, что файл скачан с неавторизованного сайта и инсталлятор не может быть запущен. В таком случае нужно зайти в «Системные настройки» — «Безопасность» (Security and Privacy), в появившемся окне будет сообщение об ошибке и кнопка Open anyway (Всё равно открыть). Нажимаем.
- Система покажет окно, уточняющее хотите ли вы запустить установку. Подтверждаем действие.
- Установщик проведёт через все необходимые шаги.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Первоначальная настройка Git

<a id="6"></a>

Работа с любой программой всегда начинается с её настройки. Git можно настроить один раз и менять что-то только по мере необходимости.

Установка имени пользователя, от которого будут идти коммиты.

`git config --global user.name "User Name"`

![Git](/img/Git/Git-setup-1.png)

Установка адреса электронной почты. Обратите внимание, что адрес должен совпадать с тем, на который зарегистрирован аккаунт в Гитхабе.

`git config --global user.email mail@gmail.com`

![Git](/img/Git/Git-setup-2.png)

С помощью команды git config --list можно посмотреть список всех установленных настроек.

![Git](/img/Git/Git-setup-3.png)

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Шпаргалка по Git

<a id="7"></a>

### Восстановление накопленных изменений

<a id="7-1"></a>

В том случае, если изменения, внесённые пользователем, находятся в режиме накопления, применить их к ветке можно с помощью команды git stash apply. Также можно запустить git diff — эта команда поможет выявить различия. Для того, чтобы затем избавиться от накопленных данных, нужно запустить команду:

```bash
git stash drop
```

Если существует более одного накопления, найти нужное можно с помощью команды:

`git stash list` затем можно применить его, воспользовавшись его индексом:

```bash
git stash@{1}
```

Необходимо учитывать, что отсчёт индексов ведётся от нуля.

### Восстановление удалённого тега

<a id="7-2"></a>

В том случае, если необходимо восстановить случайно удалённый тег, начать можно с его поиска:

```bash
git fsck --unreachable | grep ta
```

После того, как нужный тег найден, его следует восстановить:

```bash
git update-ref refs/tags/название-тега
```

### Восстановление удалённого файла

<a id="7-3"></a>

Если вы случайно удалили файл, его можно быстро восстановить:

```bash
git checkout myfile.txt
```

Если требуется восстановить файл из конкретной временной точки истории коммитов, следует узнать хеш нужного коммита и запустить команду:

```bash
git checkout $commit~1 myfile.txt
```

### Восстановление удалённой ветки

<a id="7-4"></a>

С помощью комманды git reflog можно узнать хеш (SHA1) последнего коммита в удалённой ветке. Скопируйте этот хеш и используйте в команде:

```bash
git checkout <sha>
```

После этого восстановить удалённую ветку можно будет вот такой командой:

```bash
git checkout -b <название-ветки>
```

### Изменение сообщения коммита перед его отправкой

<a id="7-5"></a>

Изменить сообщение коммита можно с помощью команды `git commit --amend`, она откроет редактор, в котором можно будет внести необходимые поправки в последнее сообщение.

Сообщение можно изменить и напрямую с помощью команды

```bash
git commit --amend -m "Новое прекрасное сообщение"
```

### Изменение сообщения коммита после его отправки

<a id="7-6"></a>

В данном случае процесс занимает два шага. Сначала нужно изменить сообщение с помощью комманды `git commit --amend`, а затем перезаписать историю коммитов локальной ветки: `git push <remote> <branch> --force`

**Предупреждение:** подобная насильная перезапись может привести к потери коммитов из внешней ветки, если с ней давно не было синхронизации, соблюдайте осторожность.

### Коммит в неправильную ветку

<a id="7-7"></a>

Нужно переключиться на новую ветку, которую вы забыли предварительно создать:

```bash
git checkout -b название-новой-ветки.
```

А затем переключиться к оригинальной ветке:

```bash
git checkout название-оригинальной-ветки
```

...и «откатиться» до последнего коммита, который нужно сохранить.

Чтобы это сделать, можно воспользоваться командой git log и сохранить хеш (SHA1) последнего коммита, который нужно оставить.. Например, это a31a45c.

Теперь его нужно сбросить: `git reset --hard a31a45c` и отправить получившийся результат.

**Предупреждение:** Убедитесь в том, что никто не отправлял коммиты в оригинальную ветку во время выполнения вышеописанных процедур, в противном случае эти изменения будут потеряны!

### Откат к конкретному коммиту в истории

<a id="7-8"></a>

Если вас не очень беспокоят изменения в локальном репозитории, то можно «откатиться» к конкретному коммиту в истории с помощью команды:

```bash
git reset --hard HEAD~1
```

Эта команда установит HEAD на конкретный коммит. Также можно воспользоваться хешем коммита.

### Отмена коммита до публикации изменений

<a id="7-9"></a>

Если вы сделали коммит, который впоследствии понадобилось отредактировать или полностью стереть, поможет команда git reset.

```bash
git reset HEAD~1 # отменить последний коммит, сохранить изменения
git reset --hard HEAD~1 # отменить последний коммит, стереть изменения
```

Будьте осторожны используя второй вариант, поскольку изменения ваших локальных файлов будут потеряны.

Чтобы сохранить сообщение коммита, наберите: :

```bash
git commit -i ORIG_HEAD
```

### Отмена коммита после отправки его в master-репозиторий

<a id="7-10"></a>

Рассмотрим процедуру возврата одного или нескольких коммитов, которые нужно стереть из удалённой ветки. Обозначить конкретный коммит можно с помощью его хеша:

```bash
git revert b712c3c
```

Отмена только коммита, который является вторым после последнего:

```bash
git revert HEAD^
```

Простая отмена последнего коммита:

```bash
git revert -n HEAD
```

### Отмена локальных изменений файлов

<a id="7-11"></a>

Простейшим способом избавиться от нежелательных изменений для файлов и папок является восстановление состояния последнего коммита. Сделать это можно с помощью специальной команды:

```bash
git checkout myfile.txt
```

Кроме того, можно восстановить конкретный путь к файлу:

```bash
git checkout -- путь-до-файла
```

### Отображение всех коммитов одного файла

<a id="7-12"></a>

Если вы хотите просмотреть все коммиты с изменениями конкретного файла, воспользуйтесь командой `git log --follow -p -- myfile`

Аргумент —follow позволяет вывести все изменения над файлом, даже если в процессе работы он был переименован.

Если опустить опцию -p, то система выведет только сообщения коммитов, но не их содержимое.

### Переименование локальной и удалённой ветки

<a id="7-13"></a>

Предложим, у вас есть ветка *«fix-bug25»*, которую вы захотели переименовать в *«hotfix-users»*. Прежде всего, нужно будет изменить локальную ветку:

```bash
git branch -m fix-bug25 hotfix-users
```

А затем — удалённую ветку: переименовать её напрямую нельзя, поэтому нужно будет её удалить, и затем опубликовать заново уже с новым именем. Прежде чем приступать к этим процедурам, следует убедиться, что никто из членов команды не работает с этой веткой! Удаляем ветку: `git push origin :fix-bug25`

А теперь заново публикуем её с новым именем: `git push origin hotfix-users`

### Переименование тега

<a id="7-14"></a>

Чтобы переименовать существующий тег:

```bash
git tag новое-название-тега старое-название-тега
git tag -d старое-название-тега
git push origin :refs/tags/старое-название-тега
git push --tags
```

### Перестать отслеживать существующие файлы

<a id="7-15"></a>

Если вы хотите перестать отслеживать файлы, которые уже есть в репозитории, но при этом желаете сохранить его локально, осуществите коммит изменений и запустите команду:

```bash
git rm -r --cached
```

Она удалит изменённые файлы из зоны подготовленных файлов (staging area). Затем нужно запустить команду:

```bash
git add .
```

и отправить изменения.

### Подготовка удалённых файлов

<a id="7-16"></a>

Чтобы подготовить к коммиту файлы и папки, которые были удалены локально, можно использовать специальную команду:

```bash
git add -u
```

Если требуется подготовить только используемый в данный момент путь, воспользуйтесь командой

```bash
git add -u .
```

### Просмотр всех неотправленных коммитов

<a id="7-17"></a>

Чтобы просмотреть все коммиты, которые ещё не были отправлены в соответствующие ветки, воспользуйтесь следующей командой:

```bash
git log --branches --not --remotes
```

Кроме того, можно использовать:

```bash
git log origin/master..HEAD
```

### Просмотр старой ревизии файла

<a id="7-18"></a>

Существует возможность просмотреть содержимое файла в конкретный момент времени в прошлом. Для этого нужно использовать команду:

```bash
git show commitHash:myfile.txt
```

### Публикация локальной ветки для удалённого редактирования

<a id="7-19"></a>

Если вы создали локальную ветку, и хотите, чтобы другие пользователи могли с ней работать, воспользуйтесь командой:

```bash
git push -u origin название-моей-новой-ветки
```

Теперь они тоже смогут вносить изменения в эту ветку.

### Сброс локальной ветки до состояния удалённой

<a id="7-20"></a>

В том случае, если отсутствуют изменения, которые необходимо сохранить, сбросить локальную ветку до состояния удалённой можно с помощью двух простых команд.

Прежде всего нужно получить свежие обновления из удалённой ветки:

```bash
git fetch название-удалённой-ветки.
```

А затем нужно сообщить git, что локальную ветку следует «откатить» до состояния удалённой:

```bash
git reset --hard origin/название-локальной-ветки.
```

При наличии коммита, который нужно сохранить, перед сбросом нужно создать новую ветку и произвести коммит: git commit -m «Обновление»

```bash
git branch название-новой-ветки
```

### Синхронизировать ветку с master-репозиторием

<a id="7-21"></a>

Чтобы синхронизировать последние изменения в репозитории master (или с любой другой веткой, с которой вы работали) необходимо «перебазировать» локальную ветку. Предположим, вы работаете над веткой foobar:

```bash
git checkout foobar
```

А затем осуществляете «перебазирование»:

```bash
git rebase master
```

После этого будут применены коммиты origin из master. После разрешения конфликтов процесс можно продолжить с помощью команды git rebase —continue. Теперь можно продолжать работу над своей веткой или осуществить её слияние (merge) с главным репозиторием.

### Слияние локальных изменений с другой веткой

<a id="7-22"></a>

Это можно сделать прямо в процессе стандартного слияния (merge). Вам стоит *сохранить историю слияний* используя флаг —no-ff, что означает *no fast forward*.

Перейдите в ветку, в которую будут вливаться изменения, убедитесь в её актуальности и запустите процесс:

```bash
git merge <другая-ветка> --no-ff
```

Затем появится сообщение о коммите merge X into Y branch, после чего вы можете смело запушить ваше слияние.>

### Создание новой ветки с изменениями текущей

<a id="7-23"></a>

Часто возникает ситуация, при которой пользователи начинают изменять файлы в ветке, чтобы что-то исправить, и лишь позднее вспоминают, что предварительно не создали новую ветку. К счастью, есть способ сделать это уже в процессе:

```bash
git checkout -b название-моей-новой-ветки
```

Эта команда перенесёт файлы из текущей ветки в новую, которую потом уже можно «закоммитить».

### Убрать файл из буфера

<a id="7-24"></a>

Чтобы убрать добавленный по ошибке файл из буфера, нужно воспользоваться простой командой:

```bash
git reset HEAD unlovedfile.txt
```

### Удаление внешней ветки

<a id="7-25"></a>

Если вы хотите удалить ветку, введите команду:

```bash
git push origin --delete название-ветки
```

### Удаление неотслеживаемых файлов и папок

<a id="7-26"></a>

Чтобы удалить неотслеживаемые файлы и папки из рабочей копии наберите следующую команду:

```bash
git clean -f
```

Чтобы в принципе удалить их:

```bash
git clean -fd
```

Подсказка: чтобы увидеть, какие файлы являются лишними, перед их непосредственным удалением, наберите:

```bash
git clean -n
```

### Удаление старых веток, стёртых из внешнего репозитория

<a id="7-27"></a>

Если ветка удалена из внешнего репозитория, её также можно стереть из локального репозитория с помощью команды

```bash
git-remote prune название-удалённой-ветки.
```

Она удалит старую ветку под названием *название-удалённой-ветки*, которая уже была стёрта из внешнего репозитория, но всё ещё доступна локально в remotes/название-удалённой-ветки.
