
# Система контроля версий Git

<a id="git"></a>

[Оглавление TIL](/README.md#start)

- [Что такое Git](#1)
- [Версионирование](#2)
- [Установка в Windows](#3)
- [Установка в Linux](#4)
- [Установка на macOS](#5)
- [Первоначальная настройка Git](#6)

Репозиторий - часть системы Git, которая позволяет совместно работать над проектами, хранилище всех версий кода. Для работы с репозиториями нужен удобный сервис. Самые популярные: GitHub, GitLab и Bitbucket.

- [Что такое GitHub и чем он отличается от Git?](/Git/GitHub/README.md)
- [GitLab – набирающая популярность альтернатива GitHub](/Git/GitLab/README.md)
- [Bitbucket – еще один популярный инструмент](/Git/Bitbucket/README.md)

Правила и команды, которые следует знать, чтобы освоить управление репозиториями на высоком уровне. Ознакомиться с ними будет полезно как новичкам, так и опытным разработчикам.

- [Основная шпаргалка по командам Git](#8)
  - [по основным командам](#8-1)
  - [по ветвлению и слиянию](#8-2)
  - [по совместной работе и обновлению проектов](#8-3)
  - [по осмотру и сравнению](#8-4)
  - [по отладке](#8-5)
- [Расширенная шпаргалка](#7)
  - [восстановление накопленных изменений](#7-1)
  - [восстановление удалённого тега](#7-2)
  - [восстановление удалённого файла](#7-3)
  - [восстановление удалённой ветки](#7-4)
  - [изменение сообщения коммита перед его отправкой](#7-5)
  - [изменение сообщения коммита после его отправки](#7-6)
  - [коммит в неправильную ветку](#7-7)
  - [откат к конкретному коммиту в истории](#7-8)
  - [отмена коммита до публикации изменений](#7-9)
  - [отмена коммита после отправки его в master-репозиторий](#7-10)
  - [отмена локальных изменений файлов](#7-11)
  - [отображение всех коммитов одного файла](#7-12)
  - [переименование локальной и удалённой ветки](#7-13)
  - [переименование тега](#7-14)
  - [перестать отслеживать существующие файлы](#7-15)
  - [подготовка удалённых файлов](#7-16)
  - [просмотр всех неотправленных коммитов](#7-17)
  - [просмотр старой ревизии файла](#7-18)
  - [публикация локальной ветки для удалённого редактирования](#7-19)
  - [сброс локальной ветки до состояния удалённой](#7-20)
  - [синхронизировать ветку с master-репозиторием](#7-21)
  - [слияние локальных изменений с другой веткой](#7-22)
  - [создание новой ветки с изменениями текущей](#7-23)
  - [убрать файл из буфера](#7-24)
  - [удаление внешней ветки](#7-25)
  - [удаление неотслеживаемых файлов и папок](#7-26)
  - [удаление старых веток, стёртых из внешнего репозитория](#7-27)
- [Как правильно составлять описания коммитов и почему это важно](#9)
  - [Семь правил хорошего описания коммита](#9-1)
- [Как фильтровать Git логи](#10)

**Полезный совет - полюбите командную строку, используйте её вместо IDE**

Используйте командную строку — на то есть столько же причин, сколько команд в Git. Командная строка — очень мощный инструмент, как и IDE, но они хороши каждый по-своему. Когда нужно использовать Git на полную катушку, командная строка вне конкуренции.

Помните об автодополнении, такая функция есть и в Bash, и в Zsh, и в Powershell. Автодополнение избавляет вас от необходимости запоминать полные команды.
  
## Что такое Git

<a id="1"></a>

Git — самая популярная распределённая система контроля версий, которая позволяет хранить разные версии одного и того же документа, переключаться
между ранними и поздними вариантами, вносить и отслеживать изменения. Поэтому в любой момент можно отменить правки или исключить ненужные части кода.

Git-сервисы позволяют переключаться между ветками кода и просматривать коммиты.

Работа с Git ведётся через командную строку. В разных операционных системах свои программы для взаимодействия с Git. В Windows их две: PowerShell и cmd.exe.
В Ubuntu это Terminal. Самая популярная программа на macOS тоже называется Terminal.
Подобные программы еще называют «терминал» или «консоль». Мы вводим команду и получаем реакцию машины: сообщение об ошибке, запрос на подтверждение
информации, результат выполненных действий.

Распределенная система контроля версий означает, что локальный клон проекта является полным репозиторием управления версиями. Полнофункциональные локальные репозитории упрощают работу в автономном режиме или в удаленном расположении.

Основное предназначение Git – это сохранение снимков последовательно улучшающихся состояний вашего проекта. С помощью Git можно отслеживать и контролировать все изменения, вносимые в базу кода проекта. Основной структурный элемент в системе Git называется репозиторий. Он представляет собой отдельный каталог на удаленном сервере, в котором хранятся все файлы для конкретного проекта: программный код, изображения, аудио, видео, документация и т.д.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Версионирование

<a id="2"></a>

Чтобы лучше понять проблему версионирования, рассмотрим пример дизайнера, который закончил работать над проектом и отправил финальную версию заказчику. У дизайнера есть папка, в которой хранится финальная версия проекта:

```text
source/
barbershop_index_final.psd
```

Всё хорошо, дизайнер закончил работу, но заказчик прислал в ответ правки. Чтобы была возможность вернуться к старой версии проекта, дизайнер создал новый файл `barbershop_index_final_2.psd`, внёс изменения и отправил заказчику:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
```

Этим всё не ограничилось, в итоге структура проекта разрослась и стала выглядеть так:

```text
source/
barbershop_index_final.psd
barbershop_index_final_2.psd
…
barbershop_index_final_19.psd
…
barbershop_index_latest_final.psd
barbershop_index_latest_final_Final.psd
```

Вероятно, многие уже сталкивались с подобным, например, при написании курсовых работ во время учёбы. В разработке создавать новые файлы для версионирования — плохая практика. Обычно у разработчиков в папке проекта хранится множество файлов. Также над одним проектом может работать несколько человек. Если каждый разработчик для версионирования будет создавать новый файл, немного изменяя название предыдущей версии, то в скором времени в проекте начнётся хаос и никто не будет понимать, какие файлы нужно открывать.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Windows

<a id="3"></a>

Скачайте exe-файл с [cайта Git](https://git-scm.com/downloads) и запустите его. Это Git для Windows, он называется msysGit. Установщик спросит добавлять ли в меню проводника возможность запуска файлов с помощью Git Bash (консольная версия) и GUI (графическая версия). Подтвердите действие, чтобы далее вести работу через консоль в Git Bash. Остальные пункты можно оставить по умолчанию.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка в Linux

<a id="4"></a>

Используйте обычный менеджер пакетов вашего дистрибутива. Откройте терминал и введите подходящие команды.

- Если у вас 21 или более ранняя версия Fedora, используйте `yum install git`.
- Для 22 и последующих версий Fedora вводите `dnf install git`.
- Для дистрибутивов, основанных на Debian, например, Ubuntu, используйте `apt-get: sudo apt-get install git`.

Полный список команд для различных дистрибутивов можно посмотреть [здесь](https://git-scm.com/download/linux).

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Установка на macOS

<a id="5"></a>

- Скачиваем Git со страницы [проекта](https://git-scm.com/download/mac).
- Запускаем загруженный файл.
- Система может показать окно с ошибкой, где будет написано, что файл скачан с неавторизованного сайта и инсталлятор не может быть запущен. В таком случае нужно зайти в «Системные настройки» — «Безопасность» (Security and Privacy), в появившемся окне будет сообщение об ошибке и кнопка Open anyway (Всё равно открыть). Нажимаем.
- Система покажет окно, уточняющее хотите ли вы запустить установку. Подтверждаем действие.
- Установщик проведёт через все необходимые шаги.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Первоначальная настройка Git

<a id="6"></a>

Работа с любой программой всегда начинается с её настройки. Git можно настроить один раз и менять что-то только по мере необходимости.

Установка имени пользователя, от которого будут идти коммиты.

`git config --global user.name "User Name"`

![Git](/img/Git/Git-setup-1.png)

Установка адреса электронной почты. Обратите внимание, что адрес должен совпадать с тем, на который зарегистрирован аккаунт в Гитхабе.

`git config --global user.email mail@gmail.com`

![Git](/img/Git/Git-setup-2.png)

С помощью команды git config --list можно посмотреть список всех установленных настроек.

![Git](/img/Git/Git-setup-3.png)

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Расширенная шпаргалка

<a id="7"></a>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление накопленных изменений

<a id="7-1"></a>

В том случае, если изменения, внесённые пользователем, находятся в режиме накопления, применить их к ветке можно с помощью команды git stash apply. Также можно запустить git diff — эта команда поможет выявить различия. Для того, чтобы затем избавиться от накопленных данных, нужно запустить команду:

```bash
git stash drop
```

Если существует более одного накопления, найти нужное можно с помощью команды:

`git stash list` затем можно применить его, воспользовавшись его индексом:

```bash
git stash@{1}
```

Необходимо учитывать, что отсчёт индексов ведётся от нуля.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённого тега

<a id="7-2"></a>

В том случае, если необходимо восстановить случайно удалённый тег, начать можно с его поиска:

```bash
git fsck --unreachable | grep ta
```

После того, как нужный тег найден, его следует восстановить:

```bash
git update-ref refs/tags/название-тега
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённого файла

<a id="7-3"></a>

Если вы случайно удалили файл, его можно быстро восстановить:

```bash
git checkout myfile.txt
```

Если требуется восстановить файл из конкретной временной точки истории коммитов, следует узнать хеш нужного коммита и запустить команду:

```bash
git checkout $commit~1 myfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Восстановление удалённой ветки

<a id="7-4"></a>

С помощью комманды git reflog можно узнать хеш (SHA1) последнего коммита в удалённой ветке. Скопируйте этот хеш и используйте в команде:

```bash
git checkout <sha>
```

После этого восстановить удалённую ветку можно будет вот такой командой:

```bash
git checkout -b <название-ветки>
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Изменение сообщения коммита перед его отправкой

<a id="7-5"></a>

Изменить сообщение коммита можно с помощью команды `git commit --amend`, она откроет редактор, в котором можно будет внести необходимые поправки в последнее сообщение.

Сообщение можно изменить и напрямую с помощью команды

```bash
git commit --amend -m "Новое прекрасное сообщение"
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Изменение сообщения коммита после его отправки

<a id="7-6"></a>

В данном случае процесс занимает два шага. Сначала нужно изменить сообщение с помощью комманды `git commit --amend`, а затем перезаписать историю коммитов локальной ветки: `git push <remote> <branch> --force`

**Предупреждение:** подобная насильная перезапись может привести к потери коммитов из внешней ветки, если с ней давно не было синхронизации, соблюдайте осторожность.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Коммит в неправильную ветку

<a id="7-7"></a>

Нужно переключиться на новую ветку, которую вы забыли предварительно создать:

```bash
git checkout -b название-новой-ветки.
```

А затем переключиться к оригинальной ветке:

```bash
git checkout название-оригинальной-ветки
```

...и «откатиться» до последнего коммита, который нужно сохранить.

Чтобы это сделать, можно воспользоваться командой git log и сохранить хеш (SHA1) последнего коммита, который нужно оставить.. Например, это a31a45c.

Теперь его нужно сбросить: `git reset --hard a31a45c` и отправить получившийся результат.

**Предупреждение:** Убедитесь в том, что никто не отправлял коммиты в оригинальную ветку во время выполнения вышеописанных процедур, в противном случае эти изменения будут потеряны!

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Откат к конкретному коммиту в истории

<a id="7-8"></a>

Если вас не очень беспокоят изменения в локальном репозитории, то можно «откатиться» к конкретному коммиту в истории с помощью команды:

```bash
git reset --hard HEAD~1
```

Эта команда установит HEAD на конкретный коммит. Также можно воспользоваться хешем коммита.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена коммита до публикации изменений

<a id="7-9"></a>

Если вы сделали коммит, который впоследствии понадобилось отредактировать или полностью стереть, поможет команда git reset.

```bash
git reset HEAD~1 # отменить последний коммит, сохранить изменения
git reset --hard HEAD~1 # отменить последний коммит, стереть изменения
```

Будьте осторожны используя второй вариант, поскольку изменения ваших локальных файлов будут потеряны.

Чтобы сохранить сообщение коммита, наберите: :

```bash
git commit -i ORIG_HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена коммита после отправки его в master-репозиторий

<a id="7-10"></a>

Рассмотрим процедуру возврата одного или нескольких коммитов, которые нужно стереть из удалённой ветки. Обозначить конкретный коммит можно с помощью его хеша:

```bash
git revert b712c3c
```

Отмена только коммита, который является вторым после последнего:

```bash
git revert HEAD^
```

Простая отмена последнего коммита:

```bash
git revert -n HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отмена локальных изменений файлов

<a id="7-11"></a>

Простейшим способом избавиться от нежелательных изменений для файлов и папок является восстановление состояния последнего коммита. Сделать это можно с помощью специальной команды:

```bash
git checkout myfile.txt
```

Кроме того, можно восстановить конкретный путь к файлу:

```bash
git checkout -- путь-до-файла
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Отображение всех коммитов одного файла

<a id="7-12"></a>

Если вы хотите просмотреть все коммиты с изменениями конкретного файла, воспользуйтесь командой `git log --follow -p -- myfile`

Аргумент —follow позволяет вывести все изменения над файлом, даже если в процессе работы он был переименован.

Если опустить опцию -p, то система выведет только сообщения коммитов, но не их содержимое.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Переименование локальной и удалённой ветки

<a id="7-13"></a>

Предложим, у вас есть ветка *«fix-bug25»*, которую вы захотели переименовать в *«hotfix-users»*. Прежде всего, нужно будет изменить локальную ветку:

```bash
git branch -m fix-bug25 hotfix-users
```

А затем — удалённую ветку: переименовать её напрямую нельзя, поэтому нужно будет её удалить, и затем опубликовать заново уже с новым именем. Прежде чем приступать к этим процедурам, следует убедиться, что никто из членов команды не работает с этой веткой! Удаляем ветку: `git push origin :fix-bug25`

А теперь заново публикуем её с новым именем: `git push origin hotfix-users`

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Переименование тега

<a id="7-14"></a>

Чтобы переименовать существующий тег:

```bash
git tag новое-название-тега старое-название-тега
git tag -d старое-название-тега
git push origin :refs/tags/старое-название-тега
git push --tags
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Перестать отслеживать существующие файлы

<a id="7-15"></a>

Если вы хотите перестать отслеживать файлы, которые уже есть в репозитории, но при этом желаете сохранить его локально, осуществите коммит изменений и запустите команду:

```bash
git rm -r --cached
```

Она удалит изменённые файлы из зоны подготовленных файлов (staging area). Затем нужно запустить команду:

```bash
git add .
```

и отправить изменения.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Подготовка удалённых файлов

<a id="7-16"></a>

Чтобы подготовить к коммиту файлы и папки, которые были удалены локально, можно использовать специальную команду:

```bash
git add -u
```

Если требуется подготовить только используемый в данный момент путь, воспользуйтесь командой

```bash
git add -u .
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Просмотр всех неотправленных коммитов

<a id="7-17"></a>

Чтобы просмотреть все коммиты, которые ещё не были отправлены в соответствующие ветки, воспользуйтесь следующей командой:

```bash
git log --branches --not --remotes
```

Кроме того, можно использовать:

```bash
git log origin/master..HEAD
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Просмотр старой ревизии файла

<a id="7-18"></a>

Существует возможность просмотреть содержимое файла в конкретный момент времени в прошлом. Для этого нужно использовать команду:

```bash
git show commitHash:myfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Публикация локальной ветки для удалённого редактирования

<a id="7-19"></a>

Если вы создали локальную ветку, и хотите, чтобы другие пользователи могли с ней работать, воспользуйтесь командой:

```bash
git push -u origin название-моей-новой-ветки
```

Теперь они тоже смогут вносить изменения в эту ветку.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Сброс локальной ветки до состояния удалённой

<a id="7-20"></a>

В том случае, если отсутствуют изменения, которые необходимо сохранить, сбросить локальную ветку до состояния удалённой можно с помощью двух простых команд.

Прежде всего нужно получить свежие обновления из удалённой ветки:

```bash
git fetch название-удалённой-ветки.
```

А затем нужно сообщить git, что локальную ветку следует «откатить» до состояния удалённой:

```bash
git reset --hard origin/название-локальной-ветки.
```

При наличии коммита, который нужно сохранить, перед сбросом нужно создать новую ветку и произвести коммит: git commit -m «Обновление»

```bash
git branch название-новой-ветки
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Синхронизировать ветку с master-репозиторием

<a id="7-21"></a>

Чтобы синхронизировать последние изменения в репозитории master (или с любой другой веткой, с которой вы работали) необходимо «перебазировать» локальную ветку. Предположим, вы работаете над веткой foobar:

```bash
git checkout foobar
```

А затем осуществляете «перебазирование»:

```bash
git rebase master
```

После этого будут применены коммиты origin из master. После разрешения конфликтов процесс можно продолжить с помощью команды git rebase —continue. Теперь можно продолжать работу над своей веткой или осуществить её слияние (merge) с главным репозиторием.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Слияние локальных изменений с другой веткой

<a id="7-22"></a>

Это можно сделать прямо в процессе стандартного слияния (merge). Вам стоит *сохранить историю слияний* используя флаг —no-ff, что означает *no fast forward*.

Перейдите в ветку, в которую будут вливаться изменения, убедитесь в её актуальности и запустите процесс:

```bash
git merge <другая-ветка> --no-ff
```

Затем появится сообщение о коммите merge X into Y branch, после чего вы можете смело запушить ваше слияние.>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Создание новой ветки с изменениями текущей

<a id="7-23"></a>

Часто возникает ситуация, при которой пользователи начинают изменять файлы в ветке, чтобы что-то исправить, и лишь позднее вспоминают, что предварительно не создали новую ветку. К счастью, есть способ сделать это уже в процессе:

```bash
git checkout -b название-моей-новой-ветки
```

Эта команда перенесёт файлы из текущей ветки в новую, которую потом уже можно «закоммитить».

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Убрать файл из буфера

<a id="7-24"></a>

Чтобы убрать добавленный по ошибке файл из буфера, нужно воспользоваться простой командой:

```bash
git reset HEAD unlovedfile.txt
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление внешней ветки

<a id="7-25"></a>

Если вы хотите удалить ветку, введите команду:

```bash
git push origin --delete название-ветки
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление неотслеживаемых файлов и папок

<a id="7-26"></a>

Чтобы удалить неотслеживаемые файлы и папки из рабочей копии наберите следующую команду:

```bash
git clean -f
```

Чтобы в принципе удалить их:

```bash
git clean -fd
```

Подсказка: чтобы увидеть, какие файлы являются лишними, перед их непосредственным удалением, наберите:

```bash
git clean -n
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Удаление старых веток, стёртых из внешнего репозитория

<a id="7-27"></a>

Если ветка удалена из внешнего репозитория, её также можно стереть из локального репозитория с помощью команды

```bash
git-remote prune название-удалённой-ветки
```

Она удалит старую ветку под названием *название-удалённой-ветки*, которая уже была стёрта из внешнего репозитория, но всё ещё доступна локально в remotes/название-удалённой-ветки.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Основная шпаргалка по командам Git

<a id="8"></a>

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По основным командам

<a id="8-1"></a>

```bash
git add
```

команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

```bash
git status
```

команда git status показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

```bash
git diff
```

команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

```bash
git difftool
```

команда git difftool просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

```bash
git commit
```

команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

```bash
git reset
```

команда git reset, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра --hard, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

```bash
git rm
```

команда git rm используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

```bash
git mv
```

команда git mv — это всего лишь удобный способ переместить файл, а затем выполнить git addдля нового файла и git rm для старого.

```bash
git clean
```

команда git clean используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По ветвлению и слиянию

<a id="8-2"></a>

```bash
git branch
```

Команда git branch — это своего рода “менеджер веток”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

```bash
git checkout
```

Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочую директорию.

```bash
git merge
```

Команда git merge используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

```bash
git mergetool
```

Команда git mergetool просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

```bash
git log
```

Команда git log используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

```bash
git stash
```

Команда git stash используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

```bash
git tag
```

Команда git tag используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По совместной работе и обновлению проектов

<a id="8-3"></a>

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

```bash
git fetch
```

Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

```bash
git pull
```

Команда git pull работает как комбинация команд git fetch и git merge, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

```bash
git push
```

Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

```bash
git remote
```

Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

```bash
git archive
```

Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

```bash
git submodule
```

Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По осмотру и сравнению

<a id="8-4"></a>

```bash
git show
```

Команда git show отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

```bash
git shortlog
```

Команда git shortlog служит для подведения итогов команды git log. Она принимает практически те же параметры, что и git log, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

```bash
git describe
```

Команда git describe принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### По отладке

<a id="8-5"></a>

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

```bash
git bisect
```

Команда git bisect — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

```bash
git blame
```

Команда git blame выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

```bash
git grep
```

Команда git grep используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Как правильно составлять описания коммитов и почему это важно

<a id="9"></a>

Заглянув в историю изменений (коммитов) какого-то рандомного Git-репозитория, вы наверняка заметите, что описания коммитов (commit messages) написаны в той или иной степени беспорядочно. Например, посмотрите на описания коммитов, которые я написал, когда начинал контрибьютить в Spring:

```text
$ git log --oneline -5 --author cbeams --before "Fri Mar 26 2009"

e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removalinr814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culpritsinthe recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.
2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTestsuntilfurther investigation determines why it causes downstream tests to fail(such as the seemingly unrelated ClassPathXmlApplicationContextTests)
147709f Tweaks to package-info.java files
22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils
7f96f57 polishing
```

Выглядит не очень привлекательно. Теперь посмотрите на описания более поздних коммитов в том же репозитории.

```text
$ git log --oneline -5 --author pwebb --before "Sat Aug 30 2014"

5ba3db6 Fix failing CompositePropertySourceTests
84564a0 Rework @PropertySource early parsing logic
e142fd1 Add testsforImportSelector meta-data
887815f Update docbook dependency and generate epub
ac8326d Polish mockito usage
```

Какие из этих описаний вы прочитаете охотнее? Старые отличаются по форме и по длине, а новые более лаконичные и однообразные. Старые как будто написаны хаотично и без системы, а новые явно писались осознанно и по упорядоченным правилам.

Как я уже говорил, примеры беспорядочных описаний можно найти в историях изменений разных репозиториев. Но есть приятные исключения, например, репозитории [ядра Linux](https://github.com/torvalds/linux/commits/master) и самого [Git](https://github.com/git/git/commits/master).

Контрибьюторы этих репозиториев понимают, что правильно оформленные описания — лучший способ передать контекст коммита другим контрибьюторам, а также будущему себе. Диф помогает понять, что именно меняет коммит. Но только описания коммитов помогут понять, *зачем* это меняется. Важность этого момента хорошо объясняет разработчик Петер Хуттерер (Peter Hutterer) [в своём посте](http://who-t.blogspot.com/2009/12/on-commit-messages.html). Вот ключевая цитата из него:

> Тратить время на восстановление контекста создания кода слишком дорого. Нельзя полностью обойтись без этого, но мы должны минимизировать такие затраты ресурсов. Правильные описания коммитов уменьшают необходимость восстанавливать контекст. В конце концов по описаниям коммитов можно понять, насколько хорошо программист работает в команде.
>

Если вы не задумывались, зачем нужны правильные описания коммитов, то наверняка вы не очень часто пользовались командой `git log`. Фактически, это порочный круг: из-за беспорядка в истории коммитов разработчики не хотят заглядывать в неё или заботиться о корректности собственных описаний коммитов. А история остаётся беспорядочной и неудобной, потому что разработчики не пользуются ей и не заботятся о корректности описаний коммитов.

Но правильно оформленная история коммитов — полезная и удобная вещь. Здесь вам пригодятся комманды `git blame`, `revert`, `rebase`, `log`, `shortlog` и так далее. С правильно оформленной историей изменений просмотр коммитов других разработчиков приобретает смысл. Кстати, при правильном оформлении истории изменений разобраться в ней можно самостоятельно, не привлекая к этой задаче авторов других коммитов. Вы получаете возможность понять, почему были внесены те или иные изменения в код несколько месяцев или лет назад.

В долгосрочной перспективе успех проекта зависит от того, насколько просто его поддерживать. У мейнтейнеров не так много инструментов, обеспечивающих простоту поддержки, которые могут сравниться по эффективности с правильно оформленной историей изменений. Поэтому стоит потратить время и научиться правильно её оформлять. Сначала необходимость правильно оформлять коммиты может показаться неудобством или лишней тратой времени. Но в конце концов эти усилия трансформируются в рост продуктивности команды и даже в повод для гордости.

Эта статья о том, как правильно составлять описания коммитов. Это простой способ сделать историю изменений репозитория читабельной и информативной.

В большинстве языков программирования есть соглашения по стилю написания кода, включая [именование](https://ru.hexlet.io/blog/posts/naming-in-programming), форматирование и так далее. Естественно, существуют разные подходы к решению тех или иных задач. Но большинство программистов уверены, что лучше выбрать одну систему и следовать ей, чем работать без соглашений и сталкиваться с хаосом, который появляется, когда каждый разработчик пишет код без какой-то системы.

Команде разработчиков также стоит придерживаться соглашений при работе с репозиториями в целом и формировании истории изменений в частности. Соглашение должно касаться как минимум трёх базовых вещей:

**Стиль**

В этот пункт входят синтаксис разметки, правила переноса, грамматика, пунктуация, использование прописных и строчных букв. Подробно опишите эти моменты и сделайте это как можно проще, чтобы избежать недопонимания. Благодаря этому вы получите историю изменений, которую не только приятно читать, но которую ещё и действительно регулярно читают разработчики.

**Контент**

Что нужно писать в описании коммита? Чего в нём быть не должно?

**Метаданные**

Как нужно отмечать ID issue, номера пулреквестов и так далее?

К счастью, есть общепринятые соглашения по поводу того, какими должны быть описания коммитов. Некоторые из них частично связаны с тем, как работают те или иные команды Git. То есть вам не придётся придумывать что-то самостоятельно. Придерживайтесь описанных ниже семи правил, и вы будете коммитить как профессионал.

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

### Семь правил хорошего описания коммита

<a id="9-1"></a>

1. **Оставляйте пустую строку между заголовком и описанием**
  
    Отрывок из справочных материалов о `git commit`:

    > Хоть это и не обязательное требование, рекомендуется начинать описание коммита со строки длиной до 50 символов, которая обобщает изменения. За ней должна следовать пустая строка, а затем более подробное описание коммита. Текст до пустой строки — это заголовок описания коммита, он может использоваться в разных командах Git. Например, Git-format-patch(1) превращает коммит в электронное письмо, в теме которого используется заголовок описания, а в теле — само описание.
    >

    Во-первых, не каждый коммит должен иметь заголовок и описание. Иногда можно ограничиться одной строкой, если изменения очень простые.

    ```text
    Fix typoinintroduction to user guide
    ```

    В данном случае дополнительная информация не нужна. Если кому-то захочется узнать, какие именно ошибки были исправлены, это можно сделать с помощью комманд `git show`, `git diff` или `git log -p`.

    Если вы делаете подобный коммит, удобно воспользоваться опцией `-m` в `git commit`:

    ```text
    $ git commit -m "Fix typo in introduction to user guide"
    ```

    А если коммит требует дополнительного объяснения, которое поможет другим разработчикам получить контекст, нужно делать подробное описание.

    ```text
    Derezz the master control program

    MCP turned out to be evil and had become intent on world domination.
    This commit throws Trons disc into MCP(causing its deresolution)
    and turns it back into a chess game. 
    ```

    Подробные описания коммитов с заголовком и телом неудобно писать с помощью опции `-m` в командной строке. В этом случае лучше делать описание коммита в редакторе. Если вы ещё не настроили редактор для работы с Git, прочитайте этот [раздел документации](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration), а также обратите внимание на наш курс [«Настройка окружения»](https://ru.hexlet.io/courses/js-setup-environment).

    В любом случае, отделять заголовок от тела описания полезно. Посмотрите на полную запись в журнале изменений.

    ```text
    $ git log
    commit 42e769bdf4894310333942ffc5a15151222a87be
    Author: Kevin Flynn <kevin@flynnsarcade.com>
    Date:   Fri Jan 01 00:00:00 1982 -0200

    Derezz the master control program

    MCP turned out to be evil and had become intent on world domination.
    This commit throws Trons disc into MCP(causing its deresolution)
    and turns it back into a chess game.
    ```

    А теперь выведем только заголовок с помощью `git log --oneline`:

    ```text
    $ git log --oneline
    42e769 Derezz the master control program
    ```

    Или с помощью команды `git shortlog` выведем сгруппированные по авторам коммиты. Здесь снова выводится только заголовок описания:

    ```text
    $ git shortlog
    Kevin Flynn(1):
          Derezz the master control program

    Alan Bradley(1):
          Introduce security program "Tron"

    Ed Dillinger(3):
          Rename chess program to "MCP"
          Modify chess program
          Upgrade chess program

    Walter Gibbs(1):
          Introduce protoype chess program
    ```

    В Git есть много других ситуаций, в которых в описании коммита важно иметь заголовок и тело. Но ни в одной ситуации это не работает, если между заголовком и телом описания нет пустой строки.

2. **Ограничивайте длину заголовка 50 символами**

    Это не жёсткое ограничение, а практически полезная рекомендация. Соблюдение этого правила гарантирует читабельность заголовка. Также она заставляет автора коммита задуматься и описать изменения максимально коротко.

    > Полезный совет: если вам тяжело коротко описать коммит, это может говорить о том, что вы вносите слишком много изменений за раз. Постарайтесь делать небольшие коммиты. Подробнее об этом можно прочитать в посте про атомарные коммиты.
    >

    Пользовательский интерфейс GitHub учитывает эти соглашения. Он предупреждает вас, если длина заголовка превышает 50 символов. А если заголовок превышает 72 символа, он обрезается. Поэтому старайтесь уложиться в 50 символов, а 72 символа считайте красной чертой.

3. **Пишите заголовок с прописной (заглавной) буквы**

    Это очень простое правило: всегда пишите заголовок описания с прописной буквы. Правильный пример:

    ```text
    Accelerate to 88 miles per hour
    ```

    Неправильный пример:

    ```text
    accelerate to 88 miles per hour
    ```

4. **Не ставьте точку в конце заголовка описания**

    Это ещё одно простое правило: в конце заголовка точка не ставится. Кстати, лишние знаки пунктуации могут помешать вам уложиться в лимит длины 50 символов, о котором шла речь выше. Правильный пример:

    ```text
    Open the pod bay doors
    ```

    Неправильный пример:

    ```text
    Open the pod bay doors.
    ```

5. **Используйте повелительное наклонение в заголовке**

    Если вы не знаете, что такое повелительное наклонение, думайте об этом так: заголовок должен быть похожим на команду или инструкцию. Вот примеры:

    - Сделай уборку
    - Закрой дверь
    - Вынеси мусор

    Все семь правил из этой статьи сформулированы в повелительном наклонении. Например, «не ставьте точку в конце заголовка», «пишите заголовок с прописной буквы».

    Повелительное наклонение может показаться грубым, поэтому мы не очень часто используем его в повседневной жизни. Но оно отлично подходит для заголовков в описаниях коммитов. Кстати, Git сам использует повелительное наклонение, когда делает коммиты от вашего имени. Например, при использовании команды `git merge` автоматически создаётся такое сообщение:

    ```text
    Merge branch 'myfeature'
    ```

    А вот сообщение, которое создаётся при использовании команды `git revert`:

    ```text
    Revert "Add the thing with the stuff"

    This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.
    ```

    Ещё один пример — сообщение, которое создаётся, когда вы нажимаете кнопку Merge, чтобы принять пулреквест:

    ```text
    Merge pull request#123 from someuser/somebranch
    ```

    Поэтому использование повелительного наклонения соответствует общепринятым соглашениям Git. Вот несколько примеров заголовков на английском языке:

    - Refactor subsystem X for readability
    - Update getting started documentation
    - Remove deprecated methods
    - Release version 1.0.0

    Повелительное наклонение может казаться немного непривычным, так как в повседневной жизни мы чаще пользуемся изъявительным наклонением. При использовании изъявительного наклонения речь больше похожа на отчёт о произошедших событиях. Заголовки описаний в изъявительном наклонении выглядят так:

    - Fixed bug with Y
    - Changing behavior of X

    Иногда заголовки просто описывают содержание коммитов:

    - More fixes for broken stuff
    - Sweet new API methods

    Чтобы раз и навсегда разобраться с заголовками описаний коммитов, запомните правило: хороший заголовок всегда должен по смыслу подходить в качестве окончания такого предложения: «If applied, this commit will (ваш заголовок)». Вот несколько примеров:

    - If applied, this commit will *refactor subsystem X for readability*
    - If applied, this commit will *update getting started documentation*
    - If applied, this commit will *remove deprecated methods*
    - If applied, this commit will *release version 1.0.0*
    - If applied, this commit will *merge pull request #123 from user/branch*

    Обратите внимание, если в заголовке не используется повелительное наклонение, он не подходит по смыслу в качестве окончания предложения:

    - If applied, this commit will *fixed bug with Y*
    - If applied, this commit will *changing behavior of X*
    - If applied, this commit will *more fixes for broken stuff*
    - If applied, this commit will *sweet new API methods*

    Обязательно использовать повелительное наклонение нужно только в заголовке. В теле описания коммита его можно не использовать.

6. **Ограничивайте длину строки в теле описания 72 символами**

    Git не переносит текст автоматически. Помните об этом и переносите строки вручную.

    Рекомендуется ограничивать длину строки 72 символами. Это позволит Git оставить в тексте нужные отступы и уложиться в предельную длину строки 80 символов.

    Соблюдать это правило поможет хороший текстовый редактор. Можно легко настроить [Vim](https://guides.hexlet.io/vim/?roistat_visit=462391) или другой редактор, чтобы он переносил строки, когда их длина достигает 72 символов.

7. **В теле описания отвечайте на вопросы «что?» и «почему?», а не «как?»**

    Пример описания ниже отлично показывает, как правильно объяснять, что и почему изменилось.

    ```text
    commit eb0b56b19017ab5c16c745e6da39c53126924ed6
    Author: Pieter Wuille <pieter.wuille@gmail.com>
    Date:   Fri Aug 1 22:57:55 2014 +0200

      Simplify serialize.h's exception handling

      Remove the 'state' and 'exceptmask' from serialize.h's stream
      implementations, as well as related methods.

      As exceptmask always included 'failbit', and setstate was always
      called with bits= failbit, all it did was immediately raise an
      exception. Get rid of those variables, and replace the setstate
      with direct exception throwing(which also removes some dead
      code).

      As a result, good() is never reached after a failure(there are
      only 2 calls, one of which isintests), and can just be replaced
      by!eof().

      fail(), clear(n) and exceptions() are just never called. Delete
      them.
    ```

    Взгляните на [изменения](https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6) и заметьте, сколько времени автор коммита сэкономил другим разработчикам с помощью описания. Он раскрыл контекст изменений, который наверняка потерялся бы без хорошего описания коммита.

    Обычно можно не писать, как именно сделаны изменения. Если код настолько сложный, что требует дополнительных пояснений, их можно сделать в комментариях. Сфокусируйтесь на объяснении причин изменений — на том, как всё работало до изменений и что здесь было не так, и на том, как оно работает сейчас.

    В будущем другие мейнтенеры поблагодарят вас за это, и, возможно, одним из них будете вы!

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)

## Как фильтровать Git логи

<a id="10"></a>

### Получение всех коммитов

```bash
git log
```

### Получение последних n коммитов

Мы можем получить последние n коммитов, выполнив команду "git log -n". Скажем, мы хотим получить последние 2 коммита.

```bash
git log -2
```

### Получение коммитов с определенной даты

Мы может фильтровать коммиты на основе даты, когда они были сделаны. Допустим, мы хотим получить все коммиты, сделанные **17.01.2022.**

```bash
git log --since 2022-01-17
```

### Получение коммитов до определенной даты

Аналогично мы можем получить коммиты, которые были сделаны до какой-то конкретной даты.

```bash
git log --until 2022-01-16
```

### Получение коммитов по автору

Мы также можем получить коммиты, сделанные определенным автором. Например:

```bash
git log --author=pipinho13
```

### Получение коммитов между двумя SHAs

Мы можем получить логи между двумя SHAs следующим образом:

```bash
git log <XXX>...<YYY>
```

где XXX и YYY - это соответствующие SHAs. Обратите внимание, мы можем заменить <YYY> на HEAD, если необходимо получить коммиты от <XXX> до настоящего момента, то есть:

```bash
git log <XXX>...HEAD
```

### Получение коммитов, относящихся к файлу

Мы можем фильтровать логи по файлам. Предположим, мы хотим получить все логи, связанные с файлом "README.md".

```bash
git log README.md
```

### Получение коммитов с использованием выражения

Мы можем использовать мощную команду "grep", чтобы фильтровать коммиты. Обычно мы ищем какое-то выражение в сообщении к коммиту. Например, давайте получим коммиты, которые содержат слово "wrong" в сообщении:

```bash
git log --grep="wrong"
```

[вернуться к меню](#git) | [оглавление TIL](/README.md#start)